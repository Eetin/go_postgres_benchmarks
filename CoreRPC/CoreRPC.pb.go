// Code generated by protoc-gen-gogo.
// source: CoreRPC.proto
// DO NOT EDIT!

/*
	Package CoreRPC is a generated protocol buffer package.

	It is generated from these files:
		CoreRPC.proto

	It has these top-level messages:
		Node
		NodeList
		TimeRange
		RequestEntry
		ChunkContainerRequest
		PlaylistRequest
		Playlist
		PlaylistEntry
		PlaylistSts
		Chunk
		ChunkList
		PlaylistMetaEntry
		EventRequest
		StreamerRequest
		StreamerInfo
		CreateEventRequest
		Zeromessage
		ChunkMetaData
		ContainerMetaData
		ChunkContainer
		StreamDescriptor
		StreamsEnum
		MediaInfo
		ContainerStat
		StreamerStsRoute
		StreamerStsRoutes
		HeartbeatState
*/
package CoreRPC

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import (
	io "io"
	//"log"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// соответствует таблице stream_types
type StreamType int32

const (
	StreamType_AudioVideoTS StreamType = 0
	StreamType_AudioOnlyAAC StreamType = 1
	StreamType_VideoOnlyTS  StreamType = 2
)

var StreamType_name = map[int32]string{
	0: "AudioVideoTS",
	1: "AudioOnlyAAC",
	2: "VideoOnlyTS",
}
var StreamType_value = map[string]int32{
	"AudioVideoTS": 0,
	"AudioOnlyAAC": 1,
	"VideoOnlyTS":  2,
}

func (x StreamType) String() string {
	return proto.EnumName(StreamType_name, int32(x))
}
func (StreamType) EnumDescriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{0} }

type HeartbeatStateMethod int32

const (
	HeartbeatState_ping HeartbeatStateMethod = 0
	HeartbeatState_pong HeartbeatStateMethod = 1
)

var HeartbeatStateMethod_name = map[int32]string{
	0: "ping",
	1: "pong",
}
var HeartbeatStateMethod_value = map[string]int32{
	"ping": 0,
	"pong": 1,
}

func (x HeartbeatStateMethod) String() string {
	return proto.EnumName(HeartbeatStateMethod_name, int32(x))
}
func (HeartbeatStateMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorCoreRPC, []int{26, 0}
}

type Node struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Region string `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{0} }

func (m *Node) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Node) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

type NodeList struct {
	Nodes []*Node `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *NodeList) Reset()                    { *m = NodeList{} }
func (m *NodeList) String() string            { return proto.CompactTextString(m) }
func (*NodeList) ProtoMessage()               {}
func (*NodeList) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{1} }

func (m *NodeList) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// элемент расписания, ToUTS=0 - лайв
type TimeRange struct {
	FromUTS int32 `protobuf:"varint,1,opt,name=FromUTS,proto3" json:"FromUTS,omitempty"`
	ToUTS   int32 `protobuf:"varint,2,opt,name=ToUTS,proto3" json:"ToUTS,omitempty"`
}

func (m *TimeRange) Reset()                    { *m = TimeRange{} }
func (m *TimeRange) String() string            { return proto.CompactTextString(m) }
func (*TimeRange) ProtoMessage()               {}
func (*TimeRange) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{2} }

func (m *TimeRange) GetFromUTS() int32 {
	if m != nil {
		return m.FromUTS
	}
	return 0
}

func (m *TimeRange) GetToUTS() int32 {
	if m != nil {
		return m.ToUTS
	}
	return 0
}

type RequestEntry struct {
	TimeRange  *TimeRange `protobuf:"bytes,1,opt,name=TimeRange" json:"TimeRange,omitempty"`
	StreamerId int64      `protobuf:"varint,2,opt,name=StreamerId,proto3" json:"StreamerId,omitempty"`
}

func (m *RequestEntry) Reset()                    { *m = RequestEntry{} }
func (m *RequestEntry) String() string            { return proto.CompactTextString(m) }
func (*RequestEntry) ProtoMessage()               {}
func (*RequestEntry) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{3} }

func (m *RequestEntry) GetTimeRange() *TimeRange {
	if m != nil {
		return m.TimeRange
	}
	return nil
}

func (m *RequestEntry) GetStreamerId() int64 {
	if m != nil {
		return m.StreamerId
	}
	return 0
}

type ChunkContainerRequest struct {
	TimeRange      *TimeRange      `protobuf:"bytes,1,opt,name=TimeRange" json:"TimeRange,omitempty"`
	ChunkContainer *ChunkContainer `protobuf:"bytes,2,opt,name=chunkContainer" json:"chunkContainer,omitempty"`
	Nodes          *NodeList       `protobuf:"bytes,3,opt,name=Nodes" json:"Nodes,omitempty"`
}

func (m *ChunkContainerRequest) Reset()                    { *m = ChunkContainerRequest{} }
func (m *ChunkContainerRequest) String() string            { return proto.CompactTextString(m) }
func (*ChunkContainerRequest) ProtoMessage()               {}
func (*ChunkContainerRequest) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{4} }

func (m *ChunkContainerRequest) GetTimeRange() *TimeRange {
	if m != nil {
		return m.TimeRange
	}
	return nil
}

func (m *ChunkContainerRequest) GetChunkContainer() *ChunkContainer {
	if m != nil {
		return m.ChunkContainer
	}
	return nil
}

func (m *ChunkContainerRequest) GetNodes() *NodeList {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// расписание  BearingStreamid - опорный поток
type PlaylistRequest struct {
	RequestEntryList []*RequestEntry `protobuf:"bytes,1,rep,name=RequestEntryList" json:"RequestEntryList,omitempty"`
	RevalidatePeriod int32           `protobuf:"varint,2,opt,name=revalidate_period,json=revalidatePeriod,proto3" json:"revalidate_period,omitempty"`
	GenerateTimeUTS  int64           `protobuf:"varint,3,opt,name=GenerateTimeUTS,proto3" json:"GenerateTimeUTS,omitempty"`
	BearingStreamid  int32           `protobuf:"varint,4,opt,name=BearingStreamid,proto3" json:"BearingStreamid,omitempty"`
	SourceNode       *Node           `protobuf:"bytes,5,opt,name=sourceNode" json:"sourceNode,omitempty"`
}

func (m *PlaylistRequest) Reset()                    { *m = PlaylistRequest{} }
func (m *PlaylistRequest) String() string            { return proto.CompactTextString(m) }
func (*PlaylistRequest) ProtoMessage()               {}
func (*PlaylistRequest) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{5} }

func (m *PlaylistRequest) GetRequestEntryList() []*RequestEntry {
	if m != nil {
		return m.RequestEntryList
	}
	return nil
}

func (m *PlaylistRequest) GetRevalidatePeriod() int32 {
	if m != nil {
		return m.RevalidatePeriod
	}
	return 0
}

func (m *PlaylistRequest) GetGenerateTimeUTS() int64 {
	if m != nil {
		return m.GenerateTimeUTS
	}
	return 0
}

func (m *PlaylistRequest) GetBearingStreamid() int32 {
	if m != nil {
		return m.BearingStreamid
	}
	return 0
}

func (m *PlaylistRequest) GetSourceNode() *Node {
	if m != nil {
		return m.SourceNode
	}
	return nil
}

// плейлист с чанками из потока BearingStreamid
type Playlist struct {
	PlaylistEntry    []*PlaylistEntry `protobuf:"bytes,1,rep,name=PlaylistEntry" json:"PlaylistEntry,omitempty"`
	RevalidatePeriod int32            `protobuf:"varint,2,opt,name=revalidate_period,json=revalidatePeriod,proto3" json:"revalidate_period,omitempty"`
	GenerateTimeUTS  int64            `protobuf:"varint,3,opt,name=GenerateTimeUTS,proto3" json:"GenerateTimeUTS,omitempty"`
	EventId          int64            `protobuf:"varint,4,opt,name=EventId,proto3" json:"EventId,omitempty"`
	SourceNode       *Node            `protobuf:"bytes,5,opt,name=sourceNode" json:"sourceNode,omitempty"`
}

func (m *Playlist) Reset()                    { *m = Playlist{} }
func (m *Playlist) String() string            { return proto.CompactTextString(m) }
func (*Playlist) ProtoMessage()               {}
func (*Playlist) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{6} }

func (m *Playlist) GetPlaylistEntry() []*PlaylistEntry {
	if m != nil {
		return m.PlaylistEntry
	}
	return nil
}

func (m *Playlist) GetRevalidatePeriod() int32 {
	if m != nil {
		return m.RevalidatePeriod
	}
	return 0
}

func (m *Playlist) GetGenerateTimeUTS() int64 {
	if m != nil {
		return m.GenerateTimeUTS
	}
	return 0
}

func (m *Playlist) GetEventId() int64 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *Playlist) GetSourceNode() *Node {
	if m != nil {
		return m.SourceNode
	}
	return nil
}

// группа элементов плейлиста, соответствующий requestEntry
type PlaylistEntry struct {
	PlaylistStsList []*PlaylistSts `protobuf:"bytes,1,rep,name=PlaylistStsList" json:"PlaylistStsList,omitempty"`
}

func (m *PlaylistEntry) Reset()                    { *m = PlaylistEntry{} }
func (m *PlaylistEntry) String() string            { return proto.CompactTextString(m) }
func (*PlaylistEntry) ProtoMessage()               {}
func (*PlaylistEntry) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{7} }

func (m *PlaylistEntry) GetPlaylistStsList() []*PlaylistSts {
	if m != nil {
		return m.PlaylistStsList
	}
	return nil
}

// элемент плейлиста - список чанков в конкретном sts для потока BearingStreamid и статистикой по всем потокам в этом sts
// статистика по потокам - хеш, где ключом является streamid
type PlaylistSts struct {
	StsUTS     int32                        `protobuf:"varint,1,opt,name=StsUTS,proto3" json:"StsUTS,omitempty"`
	ChunkList  []*Chunk                     `protobuf:"bytes,2,rep,name=ChunkList" json:"ChunkList,omitempty"`
	MetaEnties map[int32]*PlaylistMetaEntry `protobuf:"bytes,3,rep,name=metaEnties" json:"metaEnties,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PlaylistSts) Reset()                    { *m = PlaylistSts{} }
func (m *PlaylistSts) String() string            { return proto.CompactTextString(m) }
func (*PlaylistSts) ProtoMessage()               {}
func (*PlaylistSts) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{8} }

func (m *PlaylistSts) GetStsUTS() int32 {
	if m != nil {
		return m.StsUTS
	}
	return 0
}

func (m *PlaylistSts) GetChunkList() []*Chunk {
	if m != nil {
		return m.ChunkList
	}
	return nil
}

func (m *PlaylistSts) GetMetaEnties() map[int32]*PlaylistMetaEntry {
	if m != nil {
		return m.MetaEnties
	}
	return nil
}

// чанк
type Chunk struct {
	Counter     int32 `protobuf:"varint,1,opt,name=Counter,proto3" json:"Counter,omitempty"`
	Duration    int32 `protobuf:"varint,2,opt,name=Duration,proto3" json:"Duration,omitempty"`
	Cts         int32 `protobuf:"varint,3,opt,name=cts,proto3" json:"cts,omitempty"`
	ArrivalTime int64 `protobuf:"varint,5,opt,name=ArrivalTime,proto3" json:"ArrivalTime,omitempty"`
	ChunkSize   int32 `protobuf:"varint,6,opt,name=ChunkSize,proto3" json:"ChunkSize,omitempty"`
	IsLast      bool  `protobuf:"varint,7,opt,name=IsLast,proto3" json:"IsLast,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{9} }

func (m *Chunk) GetCounter() int32 {
	if m != nil {
		return m.Counter
	}
	return 0
}

func (m *Chunk) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *Chunk) GetCts() int32 {
	if m != nil {
		return m.Cts
	}
	return 0
}

func (m *Chunk) GetArrivalTime() int64 {
	if m != nil {
		return m.ArrivalTime
	}
	return 0
}

func (m *Chunk) GetChunkSize() int32 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

func (m *Chunk) GetIsLast() bool {
	if m != nil {
		return m.IsLast
	}
	return false
}

// чанклист
type ChunkList struct {
	Chunks         []*Chunk        `protobuf:"bytes,1,rep,name=Chunks" json:"Chunks,omitempty"`
	ChunkContainer *ChunkContainer `protobuf:"bytes,2,opt,name=ChunkContainer" json:"ChunkContainer,omitempty"`
	SourceNode     *Node           `protobuf:"bytes,3,opt,name=SourceNode" json:"SourceNode,omitempty"`
}

func (m *ChunkList) Reset()                    { *m = ChunkList{} }
func (m *ChunkList) String() string            { return proto.CompactTextString(m) }
func (*ChunkList) ProtoMessage()               {}
func (*ChunkList) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{10} }

func (m *ChunkList) GetChunks() []*Chunk {
	if m != nil {
		return m.Chunks
	}
	return nil
}

func (m *ChunkList) GetChunkContainer() *ChunkContainer {
	if m != nil {
		return m.ChunkContainer
	}
	return nil
}

func (m *ChunkList) GetSourceNode() *Node {
	if m != nil {
		return m.SourceNode
	}
	return nil
}

// статистика по sts конкретного потока
type PlaylistMetaEntry struct {
	EntryMaxBitRate  int32 `protobuf:"varint,1,opt,name=EntryMaxBitRate,proto3" json:"EntryMaxBitRate,omitempty"`
	EntryAvgBitRate  int32 `protobuf:"varint,2,opt,name=EntryAvgBitRate,proto3" json:"EntryAvgBitRate,omitempty"`
	EntryMaxCounter  int32 `protobuf:"varint,3,opt,name=EntryMaxCounter,proto3" json:"EntryMaxCounter,omitempty"`
	EntryMinDuration int32 `protobuf:"varint,4,opt,name=EntryMinDuration,proto3" json:"EntryMinDuration,omitempty"`
	EntryMaxDuration int32 `protobuf:"varint,5,opt,name=EntryMaxDuration,proto3" json:"EntryMaxDuration,omitempty"`
}

func (m *PlaylistMetaEntry) Reset()                    { *m = PlaylistMetaEntry{} }
func (m *PlaylistMetaEntry) String() string            { return proto.CompactTextString(m) }
func (*PlaylistMetaEntry) ProtoMessage()               {}
func (*PlaylistMetaEntry) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{11} }

func (m *PlaylistMetaEntry) GetEntryMaxBitRate() int32 {
	if m != nil {
		return m.EntryMaxBitRate
	}
	return 0
}

func (m *PlaylistMetaEntry) GetEntryAvgBitRate() int32 {
	if m != nil {
		return m.EntryAvgBitRate
	}
	return 0
}

func (m *PlaylistMetaEntry) GetEntryMaxCounter() int32 {
	if m != nil {
		return m.EntryMaxCounter
	}
	return 0
}

func (m *PlaylistMetaEntry) GetEntryMinDuration() int32 {
	if m != nil {
		return m.EntryMinDuration
	}
	return 0
}

func (m *PlaylistMetaEntry) GetEntryMaxDuration() int32 {
	if m != nil {
		return m.EntryMaxDuration
	}
	return 0
}

// запрос на получение playlistRequest
type EventRequest struct {
	EventId []int64 `protobuf:"varint,1,rep,packed,name=EventId" json:"EventId,omitempty"`
}

func (m *EventRequest) Reset()                    { *m = EventRequest{} }
func (m *EventRequest) String() string            { return proto.CompactTextString(m) }
func (*EventRequest) ProtoMessage()               {}
func (*EventRequest) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{12} }

func (m *EventRequest) GetEventId() []int64 {
	if m != nil {
		return m.EventId
	}
	return nil
}

// запрос на получение данных или регистрацию стримера
type StreamerRequest struct {
	StreamerName string `protobuf:"bytes,1,opt,name=StreamerName,proto3" json:"StreamerName,omitempty"`
	SharedKey    string `protobuf:"bytes,2,opt,name=SharedKey,proto3" json:"SharedKey,omitempty"`
	AutoRegister bool   `protobuf:"varint,3,opt,name=AutoRegister,proto3" json:"AutoRegister,omitempty"`
}

func (m *StreamerRequest) Reset()                    { *m = StreamerRequest{} }
func (m *StreamerRequest) String() string            { return proto.CompactTextString(m) }
func (*StreamerRequest) ProtoMessage()               {}
func (*StreamerRequest) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{13} }

func (m *StreamerRequest) GetStreamerName() string {
	if m != nil {
		return m.StreamerName
	}
	return ""
}

func (m *StreamerRequest) GetSharedKey() string {
	if m != nil {
		return m.SharedKey
	}
	return ""
}

func (m *StreamerRequest) GetAutoRegister() bool {
	if m != nil {
		return m.AutoRegister
	}
	return false
}

// учетная карточка стримера
type StreamerInfo struct {
	StreamerId    int64  `protobuf:"varint,1,opt,name=StreamerId,proto3" json:"StreamerId,omitempty"`
	IsNewStreamer bool   `protobuf:"varint,2,opt,name=IsNewStreamer,proto3" json:"IsNewStreamer,omitempty"`
	LastEventId   int64  `protobuf:"varint,3,opt,name=LastEventId,proto3" json:"LastEventId,omitempty"`
	StreamerName  string `protobuf:"bytes,4,opt,name=StreamerName,proto3" json:"StreamerName,omitempty"`
}

func (m *StreamerInfo) Reset()                    { *m = StreamerInfo{} }
func (m *StreamerInfo) String() string            { return proto.CompactTextString(m) }
func (*StreamerInfo) ProtoMessage()               {}
func (*StreamerInfo) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{14} }

func (m *StreamerInfo) GetStreamerId() int64 {
	if m != nil {
		return m.StreamerId
	}
	return 0
}

func (m *StreamerInfo) GetIsNewStreamer() bool {
	if m != nil {
		return m.IsNewStreamer
	}
	return false
}

func (m *StreamerInfo) GetLastEventId() int64 {
	if m != nil {
		return m.LastEventId
	}
	return 0
}

func (m *StreamerInfo) GetStreamerName() string {
	if m != nil {
		return m.StreamerName
	}
	return ""
}

// запрос на создание эвента со списком элементов расписаний
type CreateEventRequest struct {
	PlaylistRequest *PlaylistRequest `protobuf:"bytes,1,opt,name=PlaylistRequest" json:"PlaylistRequest,omitempty"`
	EventId         int64            `protobuf:"varint,2,opt,name=EventId,proto3" json:"EventId,omitempty"`
	GenerateTimeUTS int64            `protobuf:"varint,3,opt,name=GenerateTimeUTS,proto3" json:"GenerateTimeUTS,omitempty"`
}

func (m *CreateEventRequest) Reset()                    { *m = CreateEventRequest{} }
func (m *CreateEventRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateEventRequest) ProtoMessage()               {}
func (*CreateEventRequest) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{15} }

func (m *CreateEventRequest) GetPlaylistRequest() *PlaylistRequest {
	if m != nil {
		return m.PlaylistRequest
	}
	return nil
}

func (m *CreateEventRequest) GetEventId() int64 {
	if m != nil {
		return m.EventId
	}
	return 0
}

func (m *CreateEventRequest) GetGenerateTimeUTS() int64 {
	if m != nil {
		return m.GenerateTimeUTS
	}
	return 0
}

type Zeromessage struct {
}

func (m *Zeromessage) Reset()                    { *m = Zeromessage{} }
func (m *Zeromessage) String() string            { return proto.CompactTextString(m) }
func (*Zeromessage) ProtoMessage()               {}
func (*Zeromessage) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{16} }

// полный идентификатор чанка
type ChunkMetaData struct {
	ChunkContainer *ChunkContainer `protobuf:"bytes,1,opt,name=chunkContainer" json:"chunkContainer,omitempty"`
	Chunk          *Chunk          `protobuf:"bytes,2,opt,name=Chunk" json:"Chunk,omitempty"`
}

func (m *ChunkMetaData) Reset()                    { *m = ChunkMetaData{} }
func (m *ChunkMetaData) String() string            { return proto.CompactTextString(m) }
func (*ChunkMetaData) ProtoMessage()               {}
func (*ChunkMetaData) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{17} }

func (m *ChunkMetaData) GetChunkContainer() *ChunkContainer {
	if m != nil {
		return m.ChunkContainer
	}
	return nil
}

func (m *ChunkMetaData) GetChunk() *Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

type ContainerMetaData struct {
	ChunkContainer *ChunkContainer `protobuf:"bytes,1,opt,name=chunkContainer" json:"chunkContainer,omitempty"`
	ContainerStat  *ContainerStat  `protobuf:"bytes,2,opt,name=containerStat" json:"containerStat,omitempty"`
}

func (m *ContainerMetaData) Reset()                    { *m = ContainerMetaData{} }
func (m *ContainerMetaData) String() string            { return proto.CompactTextString(m) }
func (*ContainerMetaData) ProtoMessage()               {}
func (*ContainerMetaData) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{18} }

func (m *ContainerMetaData) GetChunkContainer() *ChunkContainer {
	if m != nil {
		return m.ChunkContainer
	}
	return nil
}

func (m *ContainerMetaData) GetContainerStat() *ContainerStat {
	if m != nil {
		return m.ContainerStat
	}
	return nil
}

// полный идентификатор контейнера чанка
type ChunkContainer struct {
	StreamerId int64 `protobuf:"varint,1,opt,name=StreamerId,proto3" json:"StreamerId,omitempty"`
	Sts        int32 `protobuf:"varint,2,opt,name=sts,proto3" json:"sts,omitempty"`
	Streamid   int32 `protobuf:"varint,4,opt,name=streamid,proto3" json:"streamid,omitempty"`
}

func (m *ChunkContainer) Reset()                    { *m = ChunkContainer{} }
func (m *ChunkContainer) String() string            { return proto.CompactTextString(m) }
func (*ChunkContainer) ProtoMessage()               {}
func (*ChunkContainer) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{19} }

func (m *ChunkContainer) GetStreamerId() int64 {
	if m != nil {
		return m.StreamerId
	}
	return 0
}

func (m *ChunkContainer) GetSts() int32 {
	if m != nil {
		return m.Sts
	}
	return 0
}

func (m *ChunkContainer) GetStreamid() int32 {
	if m != nil {
		return m.Streamid
	}
	return 0
}

// описание потока
type StreamDescriptor struct {
	Streamid int32      `protobuf:"varint,1,opt,name=streamid,proto3" json:"streamid,omitempty"`
	Type     StreamType `protobuf:"varint,2,opt,name=Type,proto3,enum=StreamType" json:"Type,omitempty"`
	Name     string     `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *StreamDescriptor) Reset()                    { *m = StreamDescriptor{} }
func (m *StreamDescriptor) String() string            { return proto.CompactTextString(m) }
func (*StreamDescriptor) ProtoMessage()               {}
func (*StreamDescriptor) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{20} }

func (m *StreamDescriptor) GetStreamid() int32 {
	if m != nil {
		return m.Streamid
	}
	return 0
}

func (m *StreamDescriptor) GetType() StreamType {
	if m != nil {
		return m.Type
	}
	return StreamType_AudioVideoTS
}

func (m *StreamDescriptor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// список потоков на платформе
type StreamsEnum struct {
	Map              map[string]*StreamDescriptor `protobuf:"bytes,1,rep,name=Map" json:"Map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	RevalidatePeriod int32                        `protobuf:"varint,2,opt,name=revalidate_period,json=revalidatePeriod,proto3" json:"revalidate_period,omitempty"`
	GenerateTimeUTS  int64                        `protobuf:"varint,3,opt,name=GenerateTimeUTS,proto3" json:"GenerateTimeUTS,omitempty"`
}

func (m *StreamsEnum) Reset()                    { *m = StreamsEnum{} }
func (m *StreamsEnum) String() string            { return proto.CompactTextString(m) }
func (*StreamsEnum) ProtoMessage()               {}
func (*StreamsEnum) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{21} }

func (m *StreamsEnum) GetMap() map[string]*StreamDescriptor {
	if m != nil {
		return m.Map
	}
	return nil
}

func (m *StreamsEnum) GetRevalidatePeriod() int32 {
	if m != nil {
		return m.RevalidatePeriod
	}
	return 0
}

func (m *StreamsEnum) GetGenerateTimeUTS() int64 {
	if m != nil {
		return m.GenerateTimeUTS
	}
	return 0
}

type MediaInfo struct {
	Codecs     string `protobuf:"bytes,1,opt,name=codecs,proto3" json:"codecs,omitempty"`
	Resolution string `protobuf:"bytes,2,opt,name=resolution,proto3" json:"resolution,omitempty"`
	Bitrate    uint32 `protobuf:"varint,3,opt,name=bitrate,proto3" json:"bitrate,omitempty"`
	Fps        uint32 `protobuf:"varint,4,opt,name=fps,proto3" json:"fps,omitempty"`
	Keyframe   uint32 `protobuf:"varint,5,opt,name=keyframe,proto3" json:"keyframe,omitempty"`
	Sar        string `protobuf:"bytes,6,opt,name=sar,proto3" json:"sar,omitempty"`
	Dar        string `protobuf:"bytes,7,opt,name=dar,proto3" json:"dar,omitempty"`
}

func (m *MediaInfo) Reset()                    { *m = MediaInfo{} }
func (m *MediaInfo) String() string            { return proto.CompactTextString(m) }
func (*MediaInfo) ProtoMessage()               {}
func (*MediaInfo) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{22} }

func (m *MediaInfo) GetCodecs() string {
	if m != nil {
		return m.Codecs
	}
	return ""
}

func (m *MediaInfo) GetResolution() string {
	if m != nil {
		return m.Resolution
	}
	return ""
}

func (m *MediaInfo) GetBitrate() uint32 {
	if m != nil {
		return m.Bitrate
	}
	return 0
}

func (m *MediaInfo) GetFps() uint32 {
	if m != nil {
		return m.Fps
	}
	return 0
}

func (m *MediaInfo) GetKeyframe() uint32 {
	if m != nil {
		return m.Keyframe
	}
	return 0
}

func (m *MediaInfo) GetSar() string {
	if m != nil {
		return m.Sar
	}
	return ""
}

func (m *MediaInfo) GetDar() string {
	if m != nil {
		return m.Dar
	}
	return ""
}

type ContainerStat struct {
	ContainLastChunk bool       `protobuf:"varint,1,opt,name=ContainLastChunk,proto3" json:"ContainLastChunk,omitempty"`
	MaxCts           int32      `protobuf:"varint,2,opt,name=maxCts,proto3" json:"maxCts,omitempty"`
	MaxCounter       int32      `protobuf:"varint,3,opt,name=maxCounter,proto3" json:"maxCounter,omitempty"`
	Length           int32      `protobuf:"varint,4,opt,name=length,proto3" json:"length,omitempty"`
	MediaInfo        *MediaInfo `protobuf:"bytes,5,opt,name=MediaInfo" json:"MediaInfo,omitempty"`
}

func (m *ContainerStat) Reset()                    { *m = ContainerStat{} }
func (m *ContainerStat) String() string            { return proto.CompactTextString(m) }
func (*ContainerStat) ProtoMessage()               {}
func (*ContainerStat) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{23} }

func (m *ContainerStat) GetContainLastChunk() bool {
	if m != nil {
		return m.ContainLastChunk
	}
	return false
}

func (m *ContainerStat) GetMaxCts() int32 {
	if m != nil {
		return m.MaxCts
	}
	return 0
}

func (m *ContainerStat) GetMaxCounter() int32 {
	if m != nil {
		return m.MaxCounter
	}
	return 0
}

func (m *ContainerStat) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *ContainerStat) GetMediaInfo() *MediaInfo {
	if m != nil {
		return m.MediaInfo
	}
	return nil
}

type StreamerStsRoute struct {
	ChunkContainer *ChunkContainer `protobuf:"bytes,1,opt,name=chunkContainer" json:"chunkContainer,omitempty"`
	ContainerStat  *ContainerStat  `protobuf:"bytes,2,opt,name=containerStat" json:"containerStat,omitempty"`
	SourceNode     *Node           `protobuf:"bytes,3,opt,name=sourceNode" json:"sourceNode,omitempty"`
}

func (m *StreamerStsRoute) Reset()                    { *m = StreamerStsRoute{} }
func (m *StreamerStsRoute) String() string            { return proto.CompactTextString(m) }
func (*StreamerStsRoute) ProtoMessage()               {}
func (*StreamerStsRoute) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{24} }

func (m *StreamerStsRoute) GetChunkContainer() *ChunkContainer {
	if m != nil {
		return m.ChunkContainer
	}
	return nil
}

func (m *StreamerStsRoute) GetContainerStat() *ContainerStat {
	if m != nil {
		return m.ContainerStat
	}
	return nil
}

func (m *StreamerStsRoute) GetSourceNode() *Node {
	if m != nil {
		return m.SourceNode
	}
	return nil
}

type StreamerStsRoutes struct {
	Routes []*StreamerStsRoute `protobuf:"bytes,1,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *StreamerStsRoutes) Reset()                    { *m = StreamerStsRoutes{} }
func (m *StreamerStsRoutes) String() string            { return proto.CompactTextString(m) }
func (*StreamerStsRoutes) ProtoMessage()               {}
func (*StreamerStsRoutes) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{25} }

func (m *StreamerStsRoutes) GetRoutes() []*StreamerStsRoute {
	if m != nil {
		return m.Routes
	}
	return nil
}

type HeartbeatState struct {
	Method  HeartbeatStateMethod `protobuf:"varint,1,opt,name=Method,proto3,enum=HeartbeatStateMethod" json:"Method,omitempty"`
	Payload int64                `protobuf:"varint,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *HeartbeatState) Reset()                    { *m = HeartbeatState{} }
func (m *HeartbeatState) String() string            { return proto.CompactTextString(m) }
func (*HeartbeatState) ProtoMessage()               {}
func (*HeartbeatState) Descriptor() ([]byte, []int) { return fileDescriptorCoreRPC, []int{26} }

func (m *HeartbeatState) GetMethod() HeartbeatStateMethod {
	if m != nil {
		return m.Method
	}
	return HeartbeatState_ping
}

func (m *HeartbeatState) GetPayload() int64 {
	if m != nil {
		return m.Payload
	}
	return 0
}

func init() {
	proto.RegisterType((*Node)(nil), "Node")
	proto.RegisterType((*NodeList)(nil), "NodeList")
	proto.RegisterType((*TimeRange)(nil), "TimeRange")
	proto.RegisterType((*RequestEntry)(nil), "requestEntry")
	proto.RegisterType((*ChunkContainerRequest)(nil), "ChunkContainerRequest")
	proto.RegisterType((*PlaylistRequest)(nil), "playlistRequest")
	proto.RegisterType((*Playlist)(nil), "playlist")
	proto.RegisterType((*PlaylistEntry)(nil), "playlistEntry")
	proto.RegisterType((*PlaylistSts)(nil), "playlistSts")
	proto.RegisterType((*Chunk)(nil), "chunk")
	proto.RegisterType((*ChunkList)(nil), "chunkList")
	proto.RegisterType((*PlaylistMetaEntry)(nil), "playlistMetaEntry")
	proto.RegisterType((*EventRequest)(nil), "EventRequest")
	proto.RegisterType((*StreamerRequest)(nil), "StreamerRequest")
	proto.RegisterType((*StreamerInfo)(nil), "StreamerInfo")
	proto.RegisterType((*CreateEventRequest)(nil), "CreateEventRequest")
	proto.RegisterType((*Zeromessage)(nil), "zeromessage")
	proto.RegisterType((*ChunkMetaData)(nil), "ChunkMetaData")
	proto.RegisterType((*ContainerMetaData)(nil), "ContainerMetaData")
	proto.RegisterType((*ChunkContainer)(nil), "ChunkContainer")
	proto.RegisterType((*StreamDescriptor)(nil), "StreamDescriptor")
	proto.RegisterType((*StreamsEnum)(nil), "StreamsEnum")
	proto.RegisterType((*MediaInfo)(nil), "MediaInfo")
	proto.RegisterType((*ContainerStat)(nil), "ContainerStat")
	proto.RegisterType((*StreamerStsRoute)(nil), "StreamerStsRoute")
	proto.RegisterType((*StreamerStsRoutes)(nil), "StreamerStsRoutes")
	proto.RegisterType((*HeartbeatState)(nil), "heartbeatState")
	proto.RegisterEnum("StreamType", StreamType_name, StreamType_value)
	proto.RegisterEnum("HeartbeatStateMethod", HeartbeatStateMethod_name, HeartbeatStateMethod_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for StorageService service

type StorageServiceClient interface {
	// получение плейлиста с обновлениями
	CreateContainer(ctx context.Context, in *ContainerMetaData, opts ...grpc.CallOption) (*Zeromessage, error)
	GetContainer(ctx context.Context, in *ChunkContainerRequest, opts ...grpc.CallOption) (StorageService_GetContainerClient, error)
}

type storageServiceClient struct {
	cc *grpc.ClientConn
}

func NewStorageServiceClient(cc *grpc.ClientConn) StorageServiceClient {
	return &storageServiceClient{cc}
}

func (c *storageServiceClient) CreateContainer(ctx context.Context, in *ContainerMetaData, opts ...grpc.CallOption) (*Zeromessage, error) {
	out := new(Zeromessage)
	err := grpc.Invoke(ctx, "/StorageService/CreateContainer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storageServiceClient) GetContainer(ctx context.Context, in *ChunkContainerRequest, opts ...grpc.CallOption) (StorageService_GetContainerClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StorageService_serviceDesc.Streams[0], c.cc, "/StorageService/GetContainer", opts...)
	if err != nil {
		return nil, err
	}
	x := &storageServiceGetContainerClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StorageService_GetContainerClient interface {
	Recv() (*ChunkList, error)
	grpc.ClientStream
}

type storageServiceGetContainerClient struct {
	grpc.ClientStream
}

func (x *storageServiceGetContainerClient) Recv() (*ChunkList, error) {
	m := new(ChunkList)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for StorageService service

type StorageServiceServer interface {
	// получение плейлиста с обновлениями
	CreateContainer(context.Context, *ContainerMetaData) (*Zeromessage, error)
	GetContainer(*ChunkContainerRequest, StorageService_GetContainerServer) error
}

func RegisterStorageServiceServer(s *grpc.Server, srv StorageServiceServer) {
	s.RegisterService(&_StorageService_serviceDesc, srv)
}

func _StorageService_CreateContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerMetaData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StorageServiceServer).CreateContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/StorageService/CreateContainer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StorageServiceServer).CreateContainer(ctx, req.(*ContainerMetaData))
	}
	return interceptor(ctx, in, info, handler)
}

func _StorageService_GetContainer_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChunkContainerRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StorageServiceServer).GetContainer(m, &storageServiceGetContainerServer{stream})
}

type StorageService_GetContainerServer interface {
	Send(*ChunkList) error
	grpc.ServerStream
}

type storageServiceGetContainerServer struct {
	grpc.ServerStream
}

func (x *storageServiceGetContainerServer) Send(m *ChunkList) error {
	return x.ServerStream.SendMsg(m)
}

var _StorageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "StorageService",
	HandlerType: (*StorageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateContainer",
			Handler:    _StorageService_CreateContainer_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetContainer",
			Handler:       _StorageService_GetContainer_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "CoreRPC.proto",
}

// Client API for MetaGlobalService service

type MetaGlobalServiceClient interface {
	// список потоков на платформе
	GetStreamsAvailable(ctx context.Context, in *Zeromessage, opts ...grpc.CallOption) (*StreamsEnum, error)
	// получение расписания по эвенту
	GetPlaylistRequest(ctx context.Context, in *EventRequest, opts ...grpc.CallOption) (*PlaylistRequest, error)
	// запрос на получение данных или регистрацию стримера
	GetStreamerInfo(ctx context.Context, in *StreamerRequest, opts ...grpc.CallOption) (*StreamerInfo, error)
	// запрос на создание эвента
	CreateEvent(ctx context.Context, in *CreateEventRequest, opts ...grpc.CallOption) (*Zeromessage, error)
	GetEventRequest(ctx context.Context, in *RequestEntry, opts ...grpc.CallOption) (*EventRequest, error)
}

type metaGlobalServiceClient struct {
	cc *grpc.ClientConn
}

func NewMetaGlobalServiceClient(cc *grpc.ClientConn) MetaGlobalServiceClient {
	return &metaGlobalServiceClient{cc}
}

func (c *metaGlobalServiceClient) GetStreamsAvailable(ctx context.Context, in *Zeromessage, opts ...grpc.CallOption) (*StreamsEnum, error) {
	out := new(StreamsEnum)
	err := grpc.Invoke(ctx, "/MetaGlobalService/GetStreamsAvailable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaGlobalServiceClient) GetPlaylistRequest(ctx context.Context, in *EventRequest, opts ...grpc.CallOption) (*PlaylistRequest, error) {
	out := new(PlaylistRequest)
	err := grpc.Invoke(ctx, "/MetaGlobalService/GetPlaylistRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaGlobalServiceClient) GetStreamerInfo(ctx context.Context, in *StreamerRequest, opts ...grpc.CallOption) (*StreamerInfo, error) {
	out := new(StreamerInfo)
	err := grpc.Invoke(ctx, "/MetaGlobalService/GetStreamerInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaGlobalServiceClient) CreateEvent(ctx context.Context, in *CreateEventRequest, opts ...grpc.CallOption) (*Zeromessage, error) {
	out := new(Zeromessage)
	err := grpc.Invoke(ctx, "/MetaGlobalService/CreateEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaGlobalServiceClient) GetEventRequest(ctx context.Context, in *RequestEntry, opts ...grpc.CallOption) (*EventRequest, error) {
	out := new(EventRequest)
	err := grpc.Invoke(ctx, "/MetaGlobalService/GetEventRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MetaGlobalService service

type MetaGlobalServiceServer interface {
	// список потоков на платформе
	GetStreamsAvailable(context.Context, *Zeromessage) (*StreamsEnum, error)
	// получение расписания по эвенту
	GetPlaylistRequest(context.Context, *EventRequest) (*PlaylistRequest, error)
	// запрос на получение данных или регистрацию стримера
	GetStreamerInfo(context.Context, *StreamerRequest) (*StreamerInfo, error)
	// запрос на создание эвента
	CreateEvent(context.Context, *CreateEventRequest) (*Zeromessage, error)
	GetEventRequest(context.Context, *RequestEntry) (*EventRequest, error)
}

func RegisterMetaGlobalServiceServer(s *grpc.Server, srv MetaGlobalServiceServer) {
	s.RegisterService(&_MetaGlobalService_serviceDesc, srv)
}

func _MetaGlobalService_GetStreamsAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Zeromessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaGlobalServiceServer).GetStreamsAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MetaGlobalService/GetStreamsAvailable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaGlobalServiceServer).GetStreamsAvailable(ctx, req.(*Zeromessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaGlobalService_GetPlaylistRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaGlobalServiceServer).GetPlaylistRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MetaGlobalService/GetPlaylistRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaGlobalServiceServer).GetPlaylistRequest(ctx, req.(*EventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaGlobalService_GetStreamerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaGlobalServiceServer).GetStreamerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MetaGlobalService/GetStreamerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaGlobalServiceServer).GetStreamerInfo(ctx, req.(*StreamerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaGlobalService_CreateEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaGlobalServiceServer).CreateEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MetaGlobalService/CreateEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaGlobalServiceServer).CreateEvent(ctx, req.(*CreateEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetaGlobalService_GetEventRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetaGlobalServiceServer).GetEventRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/MetaGlobalService/GetEventRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetaGlobalServiceServer).GetEventRequest(ctx, req.(*RequestEntry))
	}
	return interceptor(ctx, in, info, handler)
}

var _MetaGlobalService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MetaGlobalService",
	HandlerType: (*MetaGlobalServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStreamsAvailable",
			Handler:    _MetaGlobalService_GetStreamsAvailable_Handler,
		},
		{
			MethodName: "GetPlaylistRequest",
			Handler:    _MetaGlobalService_GetPlaylistRequest_Handler,
		},
		{
			MethodName: "GetStreamerInfo",
			Handler:    _MetaGlobalService_GetStreamerInfo_Handler,
		},
		{
			MethodName: "CreateEvent",
			Handler:    _MetaGlobalService_CreateEvent_Handler,
		},
		{
			MethodName: "GetEventRequest",
			Handler:    _MetaGlobalService_GetEventRequest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "CoreRPC.proto",
}

// Client API for StreamRouterService service

type StreamRouterServiceClient interface {
	// todo GetLastContainers
	// маршруты по контейнеру
	GetRouteByContainer(ctx context.Context, in *ChunkContainer, opts ...grpc.CallOption) (*StreamerStsRoutes, error)
	// маршруты по элементу расписания,информирование о новых маршрутах
	GetRouteByRequestEntry(ctx context.Context, in *RequestEntry, opts ...grpc.CallOption) (StreamRouterService_GetRouteByRequestEntryClient, error)
	RegisterRoutes(ctx context.Context, in *StreamerStsRoutes, opts ...grpc.CallOption) (*Zeromessage, error)
}

type streamRouterServiceClient struct {
	cc *grpc.ClientConn
}

func NewStreamRouterServiceClient(cc *grpc.ClientConn) StreamRouterServiceClient {
	return &streamRouterServiceClient{cc}
}

func (c *streamRouterServiceClient) GetRouteByContainer(ctx context.Context, in *ChunkContainer, opts ...grpc.CallOption) (*StreamerStsRoutes, error) {
	out := new(StreamerStsRoutes)
	err := grpc.Invoke(ctx, "/StreamRouterService/GetRouteByContainer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *streamRouterServiceClient) GetRouteByRequestEntry(ctx context.Context, in *RequestEntry, opts ...grpc.CallOption) (StreamRouterService_GetRouteByRequestEntryClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StreamRouterService_serviceDesc.Streams[0], c.cc, "/StreamRouterService/GetRouteByRequestEntry", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamRouterServiceGetRouteByRequestEntryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type StreamRouterService_GetRouteByRequestEntryClient interface {
	Recv() (*StreamerStsRoutes, error)
	grpc.ClientStream
}

type streamRouterServiceGetRouteByRequestEntryClient struct {
	grpc.ClientStream
}

func (x *streamRouterServiceGetRouteByRequestEntryClient) Recv() (*StreamerStsRoutes, error) {
	m := new(StreamerStsRoutes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *streamRouterServiceClient) RegisterRoutes(ctx context.Context, in *StreamerStsRoutes, opts ...grpc.CallOption) (*Zeromessage, error) {
	out := new(Zeromessage)
	err := grpc.Invoke(ctx, "/StreamRouterService/RegisterRoutes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for StreamRouterService service

type StreamRouterServiceServer interface {
	// todo GetLastContainers
	// маршруты по контейнеру
	GetRouteByContainer(context.Context, *ChunkContainer) (*StreamerStsRoutes, error)
	// маршруты по элементу расписания,информирование о новых маршрутах
	GetRouteByRequestEntry(*RequestEntry, StreamRouterService_GetRouteByRequestEntryServer) error
	RegisterRoutes(context.Context, *StreamerStsRoutes) (*Zeromessage, error)
}

func RegisterStreamRouterServiceServer(s *grpc.Server, srv StreamRouterServiceServer) {
	s.RegisterService(&_StreamRouterService_serviceDesc, srv)
}

func _StreamRouterService_GetRouteByContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChunkContainer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamRouterServiceServer).GetRouteByContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/StreamRouterService/GetRouteByContainer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamRouterServiceServer).GetRouteByContainer(ctx, req.(*ChunkContainer))
	}
	return interceptor(ctx, in, info, handler)
}

func _StreamRouterService_GetRouteByRequestEntry_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RequestEntry)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StreamRouterServiceServer).GetRouteByRequestEntry(m, &streamRouterServiceGetRouteByRequestEntryServer{stream})
}

type StreamRouterService_GetRouteByRequestEntryServer interface {
	Send(*StreamerStsRoutes) error
	grpc.ServerStream
}

type streamRouterServiceGetRouteByRequestEntryServer struct {
	grpc.ServerStream
}

func (x *streamRouterServiceGetRouteByRequestEntryServer) Send(m *StreamerStsRoutes) error {
	return x.ServerStream.SendMsg(m)
}

func _StreamRouterService_RegisterRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamerStsRoutes)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StreamRouterServiceServer).RegisterRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/StreamRouterService/RegisterRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StreamRouterServiceServer).RegisterRoutes(ctx, req.(*StreamerStsRoutes))
	}
	return interceptor(ctx, in, info, handler)
}

var _StreamRouterService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "StreamRouterService",
	HandlerType: (*StreamRouterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRouteByContainer",
			Handler:    _StreamRouterService_GetRouteByContainer_Handler,
		},
		{
			MethodName: "RegisterRoutes",
			Handler:    _StreamRouterService_RegisterRoutes_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetRouteByRequestEntry",
			Handler:       _StreamRouterService_GetRouteByRequestEntry_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "CoreRPC.proto",
}

// Client API for StreamRouterAdvertiseService service

type StreamRouterAdvertiseServiceClient interface {
	// обновление маршрутов
	AdvertiseRoute(ctx context.Context, opts ...grpc.CallOption) (StreamRouterAdvertiseService_AdvertiseRouteClient, error)
}

type streamRouterAdvertiseServiceClient struct {
	cc *grpc.ClientConn
}

func NewStreamRouterAdvertiseServiceClient(cc *grpc.ClientConn) StreamRouterAdvertiseServiceClient {
	return &streamRouterAdvertiseServiceClient{cc}
}

func (c *streamRouterAdvertiseServiceClient) AdvertiseRoute(ctx context.Context, opts ...grpc.CallOption) (StreamRouterAdvertiseService_AdvertiseRouteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_StreamRouterAdvertiseService_serviceDesc.Streams[0], c.cc, "/StreamRouterAdvertiseService/AdvertiseRoute", opts...)
	if err != nil {
		return nil, err
	}
	x := &streamRouterAdvertiseServiceAdvertiseRouteClient{stream}
	return x, nil
}

type StreamRouterAdvertiseService_AdvertiseRouteClient interface {
	Send(*StreamerStsRoutes) error
	CloseAndRecv() (*Zeromessage, error)
	grpc.ClientStream
}

type streamRouterAdvertiseServiceAdvertiseRouteClient struct {
	grpc.ClientStream
}

func (x *streamRouterAdvertiseServiceAdvertiseRouteClient) Send(m *StreamerStsRoutes) error {
	return x.ClientStream.SendMsg(m)
}

func (x *streamRouterAdvertiseServiceAdvertiseRouteClient) CloseAndRecv() (*Zeromessage, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Zeromessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for StreamRouterAdvertiseService service

type StreamRouterAdvertiseServiceServer interface {
	// обновление маршрутов
	AdvertiseRoute(StreamRouterAdvertiseService_AdvertiseRouteServer) error
}

func RegisterStreamRouterAdvertiseServiceServer(s *grpc.Server, srv StreamRouterAdvertiseServiceServer) {
	s.RegisterService(&_StreamRouterAdvertiseService_serviceDesc, srv)
}

func _StreamRouterAdvertiseService_AdvertiseRoute_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(StreamRouterAdvertiseServiceServer).AdvertiseRoute(&streamRouterAdvertiseServiceAdvertiseRouteServer{stream})
}

type StreamRouterAdvertiseService_AdvertiseRouteServer interface {
	SendAndClose(*Zeromessage) error
	Recv() (*StreamerStsRoutes, error)
	grpc.ServerStream
}

type streamRouterAdvertiseServiceAdvertiseRouteServer struct {
	grpc.ServerStream
}

func (x *streamRouterAdvertiseServiceAdvertiseRouteServer) SendAndClose(m *Zeromessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *streamRouterAdvertiseServiceAdvertiseRouteServer) Recv() (*StreamerStsRoutes, error) {
	m := new(StreamerStsRoutes)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _StreamRouterAdvertiseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "StreamRouterAdvertiseService",
	HandlerType: (*StreamRouterAdvertiseServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AdvertiseRoute",
			Handler:       _StreamRouterAdvertiseService_AdvertiseRoute_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "CoreRPC.proto",
}

// Client API for TranscoderService service

type TranscoderServiceClient interface {
	// маршруты по контейнеру
	Notify(ctx context.Context, in *ChunkMetaData, opts ...grpc.CallOption) (*Zeromessage, error)
}

type transcoderServiceClient struct {
	cc *grpc.ClientConn
}

func NewTranscoderServiceClient(cc *grpc.ClientConn) TranscoderServiceClient {
	return &transcoderServiceClient{cc}
}

func (c *transcoderServiceClient) Notify(ctx context.Context, in *ChunkMetaData, opts ...grpc.CallOption) (*Zeromessage, error) {
	out := new(Zeromessage)
	err := grpc.Invoke(ctx, "/TranscoderService/Notify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TranscoderService service

type TranscoderServiceServer interface {
	// маршруты по контейнеру
	Notify(context.Context, *ChunkMetaData) (*Zeromessage, error)
}

func RegisterTranscoderServiceServer(s *grpc.Server, srv TranscoderServiceServer) {
	s.RegisterService(&_TranscoderService_serviceDesc, srv)
}

func _TranscoderService_Notify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChunkMetaData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TranscoderServiceServer).Notify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/TranscoderService/Notify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TranscoderServiceServer).Notify(ctx, req.(*ChunkMetaData))
	}
	return interceptor(ctx, in, info, handler)
}

var _TranscoderService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "TranscoderService",
	HandlerType: (*TranscoderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Notify",
			Handler:    _TranscoderService_Notify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "CoreRPC.proto",
}

// Client API for ControlService service

type ControlServiceClient interface {
	RegisterUser(ctx context.Context, in *StreamerRequest, opts ...grpc.CallOption) (*StreamerInfo, error)
	RegisterContainer(ctx context.Context, in *ContainerMetaData, opts ...grpc.CallOption) (*NodeList, error)
}

type controlServiceClient struct {
	cc *grpc.ClientConn
}

func NewControlServiceClient(cc *grpc.ClientConn) ControlServiceClient {
	return &controlServiceClient{cc}
}

func (c *controlServiceClient) RegisterUser(ctx context.Context, in *StreamerRequest, opts ...grpc.CallOption) (*StreamerInfo, error) {
	out := new(StreamerInfo)
	err := grpc.Invoke(ctx, "/ControlService/RegisterUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controlServiceClient) RegisterContainer(ctx context.Context, in *ContainerMetaData, opts ...grpc.CallOption) (*NodeList, error) {
	out := new(NodeList)
	err := grpc.Invoke(ctx, "/ControlService/RegisterContainer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ControlService service

type ControlServiceServer interface {
	RegisterUser(context.Context, *StreamerRequest) (*StreamerInfo, error)
	RegisterContainer(context.Context, *ContainerMetaData) (*NodeList, error)
}

func RegisterControlServiceServer(s *grpc.Server, srv ControlServiceServer) {
	s.RegisterService(&_ControlService_serviceDesc, srv)
}

func _ControlService_RegisterUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).RegisterUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ControlService/RegisterUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).RegisterUser(ctx, req.(*StreamerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControlService_RegisterContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerMetaData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControlServiceServer).RegisterContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ControlService/RegisterContainer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControlServiceServer).RegisterContainer(ctx, req.(*ContainerMetaData))
	}
	return interceptor(ctx, in, info, handler)
}

var _ControlService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ControlService",
	HandlerType: (*ControlServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterUser",
			Handler:    _ControlService_RegisterUser_Handler,
		},
		{
			MethodName: "RegisterContainer",
			Handler:    _ControlService_RegisterContainer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "CoreRPC.proto",
}

// Client API for Heartbeat service

type HeartbeatClient interface {
	StateStream(ctx context.Context, opts ...grpc.CallOption) (Heartbeat_StateStreamClient, error)
}

type heartbeatClient struct {
	cc *grpc.ClientConn
}

func NewHeartbeatClient(cc *grpc.ClientConn) HeartbeatClient {
	return &heartbeatClient{cc}
}

func (c *heartbeatClient) StateStream(ctx context.Context, opts ...grpc.CallOption) (Heartbeat_StateStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Heartbeat_serviceDesc.Streams[0], c.cc, "/heartbeat/StateStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &heartbeatStateStreamClient{stream}
	return x, nil
}

type Heartbeat_StateStreamClient interface {
	Send(*HeartbeatState) error
	Recv() (*HeartbeatState, error)
	grpc.ClientStream
}

type heartbeatStateStreamClient struct {
	grpc.ClientStream
}

func (x *heartbeatStateStreamClient) Send(m *HeartbeatState) error {
	return x.ClientStream.SendMsg(m)
}

func (x *heartbeatStateStreamClient) Recv() (*HeartbeatState, error) {
	m := new(HeartbeatState)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Heartbeat service

type HeartbeatServer interface {
	StateStream(Heartbeat_StateStreamServer) error
}

func RegisterHeartbeatServer(s *grpc.Server, srv HeartbeatServer) {
	s.RegisterService(&_Heartbeat_serviceDesc, srv)
}

func _Heartbeat_StateStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HeartbeatServer).StateStream(&heartbeatStateStreamServer{stream})
}

type Heartbeat_StateStreamServer interface {
	Send(*HeartbeatState) error
	Recv() (*HeartbeatState, error)
	grpc.ServerStream
}

type heartbeatStateStreamServer struct {
	grpc.ServerStream
}

func (x *heartbeatStateStreamServer) Send(m *HeartbeatState) error {
	return x.ServerStream.SendMsg(m)
}

func (x *heartbeatStateStreamServer) Recv() (*HeartbeatState, error) {
	m := new(HeartbeatState)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Heartbeat_serviceDesc = grpc.ServiceDesc{
	ServiceName: "heartbeat",
	HandlerType: (*HeartbeatServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StateStream",
			Handler:       _Heartbeat_StateStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "CoreRPC.proto",
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	return i, nil
}

func (m *NodeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoreRPC(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TimeRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromUTS != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.FromUTS))
	}
	if m.ToUTS != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.ToUTS))
	}
	return i, nil
}

func (m *RequestEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimeRange != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.TimeRange.Size()))
		n1, err := m.TimeRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.StreamerId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.StreamerId))
	}
	return i, nil
}

func (m *ChunkContainerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkContainerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimeRange != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.TimeRange.Size()))
		n2, err := m.TimeRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ChunkContainer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.ChunkContainer.Size()))
		n3, err := m.ChunkContainer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Nodes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Nodes.Size()))
		n4, err := m.Nodes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *PlaylistRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlaylistRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RequestEntryList) > 0 {
		for _, msg := range m.RequestEntryList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoreRPC(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RevalidatePeriod != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.RevalidatePeriod))
	}
	if m.GenerateTimeUTS != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.GenerateTimeUTS))
	}
	if m.BearingStreamid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.BearingStreamid))
	}
	if m.SourceNode != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.SourceNode.Size()))
		n5, err := m.SourceNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Playlist) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Playlist) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlaylistEntry) > 0 {
		for _, msg := range m.PlaylistEntry {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoreRPC(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RevalidatePeriod != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.RevalidatePeriod))
	}
	if m.GenerateTimeUTS != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.GenerateTimeUTS))
	}
	if m.EventId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.EventId))
	}
	if m.SourceNode != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.SourceNode.Size()))
		n6, err := m.SourceNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *PlaylistEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlaylistEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlaylistStsList) > 0 {
		for _, msg := range m.PlaylistStsList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoreRPC(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PlaylistSts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlaylistSts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StsUTS != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.StsUTS))
	}
	if len(m.ChunkList) > 0 {
		for _, msg := range m.ChunkList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCoreRPC(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MetaEnties) > 0 {
		for k, _ := range m.MetaEnties {
			dAtA[i] = 0x1a
			i++
			v := m.MetaEnties[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCoreRPC(uint64(msgSize))
			}
			mapSize := 1 + sovCoreRPC(uint64(k)) + msgSize
			i = encodeVarintCoreRPC(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintCoreRPC(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCoreRPC(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	return i, nil
}

func (m *Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Counter != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Counter))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Duration))
	}
	if m.Cts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Cts))
	}
	if m.ArrivalTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.ArrivalTime))
	}
	if m.ChunkSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.ChunkSize))
	}
	if m.IsLast {
		dAtA[i] = 0x38
		i++
		if m.IsLast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChunkList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, msg := range m.Chunks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoreRPC(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ChunkContainer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.ChunkContainer.Size()))
		n8, err := m.ChunkContainer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.SourceNode != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.SourceNode.Size()))
		n9, err := m.SourceNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *PlaylistMetaEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlaylistMetaEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntryMaxBitRate != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.EntryMaxBitRate))
	}
	if m.EntryAvgBitRate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.EntryAvgBitRate))
	}
	if m.EntryMaxCounter != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.EntryMaxCounter))
	}
	if m.EntryMinDuration != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.EntryMinDuration))
	}
	if m.EntryMaxDuration != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.EntryMaxDuration))
	}
	return i, nil
}

func (m *EventRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EventId) > 0 {
		dAtA11 := make([]byte, len(m.EventId)*10)
		var j10 int
		for _, num1 := range m.EventId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *StreamerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamerRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StreamerName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(len(m.StreamerName)))
		i += copy(dAtA[i:], m.StreamerName)
	}
	if len(m.SharedKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(len(m.SharedKey)))
		i += copy(dAtA[i:], m.SharedKey)
	}
	if m.AutoRegister {
		dAtA[i] = 0x18
		i++
		if m.AutoRegister {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StreamerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StreamerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.StreamerId))
	}
	if m.IsNewStreamer {
		dAtA[i] = 0x10
		i++
		if m.IsNewStreamer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastEventId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.LastEventId))
	}
	if len(m.StreamerName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(len(m.StreamerName)))
		i += copy(dAtA[i:], m.StreamerName)
	}
	return i, nil
}

func (m *CreateEventRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateEventRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlaylistRequest != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.PlaylistRequest.Size()))
		n12, err := m.PlaylistRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.EventId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.EventId))
	}
	if m.GenerateTimeUTS != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.GenerateTimeUTS))
	}
	return i, nil
}

func (m *Zeromessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Zeromessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ChunkMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkMetaData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChunkContainer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.ChunkContainer.Size()))
		n13, err := m.ChunkContainer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Chunk != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Chunk.Size()))
		n14, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *ContainerMetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerMetaData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChunkContainer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.ChunkContainer.Size()))
		n15, err := m.ChunkContainer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.ContainerStat != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.ContainerStat.Size()))
		n16, err := m.ContainerStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *ChunkContainer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChunkContainer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StreamerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.StreamerId))
	}
	if m.Sts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Sts))
	}
	if m.Streamid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Streamid))
	}
	return i, nil
}

func (m *StreamDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Streamid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Streamid))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Type))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *StreamsEnum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamsEnum) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, _ := range m.Map {
			dAtA[i] = 0xa
			i++
			v := m.Map[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCoreRPC(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCoreRPC(uint64(len(k))) + msgSize
			i = encodeVarintCoreRPC(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoreRPC(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCoreRPC(dAtA, i, uint64(v.Size()))
				n17, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n17
			}
		}
	}
	if m.RevalidatePeriod != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.RevalidatePeriod))
	}
	if m.GenerateTimeUTS != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.GenerateTimeUTS))
	}
	return i, nil
}

func (m *MediaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Codecs) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(len(m.Codecs)))
		i += copy(dAtA[i:], m.Codecs)
	}
	if len(m.Resolution) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(len(m.Resolution)))
		i += copy(dAtA[i:], m.Resolution)
	}
	if m.Bitrate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Bitrate))
	}
	if m.Fps != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Fps))
	}
	if m.Keyframe != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Keyframe))
	}
	if len(m.Sar) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(len(m.Sar)))
		i += copy(dAtA[i:], m.Sar)
	}
	if len(m.Dar) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(len(m.Dar)))
		i += copy(dAtA[i:], m.Dar)
	}
	return i, nil
}

func (m *ContainerStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerStat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainLastChunk {
		dAtA[i] = 0x8
		i++
		if m.ContainLastChunk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxCts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.MaxCts))
	}
	if m.MaxCounter != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.MaxCounter))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Length))
	}
	if m.MediaInfo != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.MediaInfo.Size()))
		n18, err := m.MediaInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *StreamerStsRoute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamerStsRoute) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChunkContainer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.ChunkContainer.Size()))
		n19, err := m.ChunkContainer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.ContainerStat != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.ContainerStat.Size()))
		n20, err := m.ContainerStat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.SourceNode != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.SourceNode.Size()))
		n21, err := m.SourceNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *StreamerStsRoutes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamerStsRoutes) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCoreRPC(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HeartbeatState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Method != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Method))
	}
	if m.Payload != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCoreRPC(dAtA, i, uint64(m.Payload))
	}
	return i, nil
}

func encodeFixed64CoreRPC(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32CoreRPC(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintCoreRPC(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *NodeList) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovCoreRPC(uint64(l))
		}
	}
	return n
}

func (m *TimeRange) Size() (n int) {
	var l int
	_ = l
	if m.FromUTS != 0 {
		n += 1 + sovCoreRPC(uint64(m.FromUTS))
	}
	if m.ToUTS != 0 {
		n += 1 + sovCoreRPC(uint64(m.ToUTS))
	}
	return n
}

func (m *RequestEntry) Size() (n int) {
	var l int
	_ = l
	if m.TimeRange != nil {
		l = m.TimeRange.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.StreamerId != 0 {
		n += 1 + sovCoreRPC(uint64(m.StreamerId))
	}
	return n
}

func (m *ChunkContainerRequest) Size() (n int) {
	var l int
	_ = l
	if m.TimeRange != nil {
		l = m.TimeRange.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.ChunkContainer != nil {
		l = m.ChunkContainer.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.Nodes != nil {
		l = m.Nodes.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *PlaylistRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.RequestEntryList) > 0 {
		for _, e := range m.RequestEntryList {
			l = e.Size()
			n += 1 + l + sovCoreRPC(uint64(l))
		}
	}
	if m.RevalidatePeriod != 0 {
		n += 1 + sovCoreRPC(uint64(m.RevalidatePeriod))
	}
	if m.GenerateTimeUTS != 0 {
		n += 1 + sovCoreRPC(uint64(m.GenerateTimeUTS))
	}
	if m.BearingStreamid != 0 {
		n += 1 + sovCoreRPC(uint64(m.BearingStreamid))
	}
	if m.SourceNode != nil {
		l = m.SourceNode.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *Playlist) Size() (n int) {
	var l int
	_ = l
	if len(m.PlaylistEntry) > 0 {
		for _, e := range m.PlaylistEntry {
			l = e.Size()
			n += 1 + l + sovCoreRPC(uint64(l))
		}
	}
	if m.RevalidatePeriod != 0 {
		n += 1 + sovCoreRPC(uint64(m.RevalidatePeriod))
	}
	if m.GenerateTimeUTS != 0 {
		n += 1 + sovCoreRPC(uint64(m.GenerateTimeUTS))
	}
	if m.EventId != 0 {
		n += 1 + sovCoreRPC(uint64(m.EventId))
	}
	if m.SourceNode != nil {
		l = m.SourceNode.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *PlaylistEntry) Size() (n int) {
	var l int
	_ = l
	if len(m.PlaylistStsList) > 0 {
		for _, e := range m.PlaylistStsList {
			l = e.Size()
			n += 1 + l + sovCoreRPC(uint64(l))
		}
	}
	return n
}

func (m *PlaylistSts) Size() (n int) {
	var l int
	_ = l
	if m.StsUTS != 0 {
		n += 1 + sovCoreRPC(uint64(m.StsUTS))
	}
	if len(m.ChunkList) > 0 {
		for _, e := range m.ChunkList {
			l = e.Size()
			n += 1 + l + sovCoreRPC(uint64(l))
		}
	}
	if len(m.MetaEnties) > 0 {
		for k, v := range m.MetaEnties {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCoreRPC(uint64(l))
			}
			mapEntrySize := 1 + sovCoreRPC(uint64(k)) + l
			n += mapEntrySize + 1 + sovCoreRPC(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Chunk) Size() (n int) {
	var l int
	_ = l
	if m.Counter != 0 {
		n += 1 + sovCoreRPC(uint64(m.Counter))
	}
	if m.Duration != 0 {
		n += 1 + sovCoreRPC(uint64(m.Duration))
	}
	if m.Cts != 0 {
		n += 1 + sovCoreRPC(uint64(m.Cts))
	}
	if m.ArrivalTime != 0 {
		n += 1 + sovCoreRPC(uint64(m.ArrivalTime))
	}
	if m.ChunkSize != 0 {
		n += 1 + sovCoreRPC(uint64(m.ChunkSize))
	}
	if m.IsLast {
		n += 2
	}
	return n
}

func (m *ChunkList) Size() (n int) {
	var l int
	_ = l
	if len(m.Chunks) > 0 {
		for _, e := range m.Chunks {
			l = e.Size()
			n += 1 + l + sovCoreRPC(uint64(l))
		}
	}
	if m.ChunkContainer != nil {
		l = m.ChunkContainer.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.SourceNode != nil {
		l = m.SourceNode.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *PlaylistMetaEntry) Size() (n int) {
	var l int
	_ = l
	if m.EntryMaxBitRate != 0 {
		n += 1 + sovCoreRPC(uint64(m.EntryMaxBitRate))
	}
	if m.EntryAvgBitRate != 0 {
		n += 1 + sovCoreRPC(uint64(m.EntryAvgBitRate))
	}
	if m.EntryMaxCounter != 0 {
		n += 1 + sovCoreRPC(uint64(m.EntryMaxCounter))
	}
	if m.EntryMinDuration != 0 {
		n += 1 + sovCoreRPC(uint64(m.EntryMinDuration))
	}
	if m.EntryMaxDuration != 0 {
		n += 1 + sovCoreRPC(uint64(m.EntryMaxDuration))
	}
	return n
}

func (m *EventRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.EventId) > 0 {
		l = 0
		for _, e := range m.EventId {
			l += sovCoreRPC(uint64(e))
		}
		n += 1 + sovCoreRPC(uint64(l)) + l
	}
	return n
}

func (m *StreamerRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.StreamerName)
	if l > 0 {
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	l = len(m.SharedKey)
	if l > 0 {
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.AutoRegister {
		n += 2
	}
	return n
}

func (m *StreamerInfo) Size() (n int) {
	var l int
	_ = l
	if m.StreamerId != 0 {
		n += 1 + sovCoreRPC(uint64(m.StreamerId))
	}
	if m.IsNewStreamer {
		n += 2
	}
	if m.LastEventId != 0 {
		n += 1 + sovCoreRPC(uint64(m.LastEventId))
	}
	l = len(m.StreamerName)
	if l > 0 {
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *CreateEventRequest) Size() (n int) {
	var l int
	_ = l
	if m.PlaylistRequest != nil {
		l = m.PlaylistRequest.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.EventId != 0 {
		n += 1 + sovCoreRPC(uint64(m.EventId))
	}
	if m.GenerateTimeUTS != 0 {
		n += 1 + sovCoreRPC(uint64(m.GenerateTimeUTS))
	}
	return n
}

func (m *Zeromessage) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ChunkMetaData) Size() (n int) {
	var l int
	_ = l
	if m.ChunkContainer != nil {
		l = m.ChunkContainer.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.Chunk != nil {
		l = m.Chunk.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *ContainerMetaData) Size() (n int) {
	var l int
	_ = l
	if m.ChunkContainer != nil {
		l = m.ChunkContainer.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.ContainerStat != nil {
		l = m.ContainerStat.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *ChunkContainer) Size() (n int) {
	var l int
	_ = l
	if m.StreamerId != 0 {
		n += 1 + sovCoreRPC(uint64(m.StreamerId))
	}
	if m.Sts != 0 {
		n += 1 + sovCoreRPC(uint64(m.Sts))
	}
	if m.Streamid != 0 {
		n += 1 + sovCoreRPC(uint64(m.Streamid))
	}
	return n
}

func (m *StreamDescriptor) Size() (n int) {
	var l int
	_ = l
	if m.Streamid != 0 {
		n += 1 + sovCoreRPC(uint64(m.Streamid))
	}
	if m.Type != 0 {
		n += 1 + sovCoreRPC(uint64(m.Type))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *StreamsEnum) Size() (n int) {
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCoreRPC(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCoreRPC(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCoreRPC(uint64(mapEntrySize))
		}
	}
	if m.RevalidatePeriod != 0 {
		n += 1 + sovCoreRPC(uint64(m.RevalidatePeriod))
	}
	if m.GenerateTimeUTS != 0 {
		n += 1 + sovCoreRPC(uint64(m.GenerateTimeUTS))
	}
	return n
}

func (m *MediaInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Codecs)
	if l > 0 {
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	l = len(m.Resolution)
	if l > 0 {
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.Bitrate != 0 {
		n += 1 + sovCoreRPC(uint64(m.Bitrate))
	}
	if m.Fps != 0 {
		n += 1 + sovCoreRPC(uint64(m.Fps))
	}
	if m.Keyframe != 0 {
		n += 1 + sovCoreRPC(uint64(m.Keyframe))
	}
	l = len(m.Sar)
	if l > 0 {
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	l = len(m.Dar)
	if l > 0 {
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *ContainerStat) Size() (n int) {
	var l int
	_ = l
	if m.ContainLastChunk {
		n += 2
	}
	if m.MaxCts != 0 {
		n += 1 + sovCoreRPC(uint64(m.MaxCts))
	}
	if m.MaxCounter != 0 {
		n += 1 + sovCoreRPC(uint64(m.MaxCounter))
	}
	if m.Length != 0 {
		n += 1 + sovCoreRPC(uint64(m.Length))
	}
	if m.MediaInfo != nil {
		l = m.MediaInfo.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *StreamerStsRoute) Size() (n int) {
	var l int
	_ = l
	if m.ChunkContainer != nil {
		l = m.ChunkContainer.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.ContainerStat != nil {
		l = m.ContainerStat.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	if m.SourceNode != nil {
		l = m.SourceNode.Size()
		n += 1 + l + sovCoreRPC(uint64(l))
	}
	return n
}

func (m *StreamerStsRoutes) Size() (n int) {
	var l int
	_ = l
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovCoreRPC(uint64(l))
		}
	}
	return n
}

func (m *HeartbeatState) Size() (n int) {
	var l int
	_ = l
	if m.Method != 0 {
		n += 1 + sovCoreRPC(uint64(m.Method))
	}
	if m.Payload != 0 {
		n += 1 + sovCoreRPC(uint64(m.Payload))
	}
	return n
}

func sovCoreRPC(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCoreRPC(x uint64) (n int) {
	return sovCoreRPC(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUTS", wireType)
			}
			m.FromUTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUTS |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToUTS", wireType)
			}
			m.ToUTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToUTS |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: requestEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: requestEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeRange == nil {
				m.TimeRange = &TimeRange{}
			}
			if err := m.TimeRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamerId", wireType)
			}
			m.StreamerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamerId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkContainerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChunkContainerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChunkContainerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TimeRange == nil {
				m.TimeRange = &TimeRange{}
			}
			if err := m.TimeRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkContainer == nil {
				m.ChunkContainer = &ChunkContainer{}
			}
			if err := m.ChunkContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodes == nil {
				m.Nodes = &NodeList{}
			}
			if err := m.Nodes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlaylistRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: playlistRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: playlistRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestEntryList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestEntryList = append(m.RequestEntryList, &RequestEntry{})
			if err := m.RequestEntryList[len(m.RequestEntryList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevalidatePeriod", wireType)
			}
			m.RevalidatePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevalidatePeriod |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateTimeUTS", wireType)
			}
			m.GenerateTimeUTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenerateTimeUTS |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearingStreamid", wireType)
			}
			m.BearingStreamid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BearingStreamid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceNode == nil {
				m.SourceNode = &Node{}
			}
			if err := m.SourceNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Playlist) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: playlist: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: playlist: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaylistEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlaylistEntry = append(m.PlaylistEntry, &PlaylistEntry{})
			if err := m.PlaylistEntry[len(m.PlaylistEntry)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevalidatePeriod", wireType)
			}
			m.RevalidatePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevalidatePeriod |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateTimeUTS", wireType)
			}
			m.GenerateTimeUTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenerateTimeUTS |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceNode == nil {
				m.SourceNode = &Node{}
			}
			if err := m.SourceNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlaylistEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: playlistEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: playlistEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaylistStsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlaylistStsList = append(m.PlaylistStsList, &PlaylistSts{})
			if err := m.PlaylistStsList[len(m.PlaylistStsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlaylistSts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: playlistSts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: playlistSts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StsUTS", wireType)
			}
			m.StsUTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StsUTS |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChunkList = append(m.ChunkList, &Chunk{})
			if err := m.ChunkList[len(m.ChunkList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaEnties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.MetaEnties == nil {
				m.MetaEnties = make(map[int32]*PlaylistMetaEntry)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoreRPC
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoreRPC
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthCoreRPC
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthCoreRPC
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &PlaylistMetaEntry{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.MetaEnties[mapkey] = mapvalue
			} else {
				var mapvalue *PlaylistMetaEntry
				m.MetaEnties[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cts", wireType)
			}
			m.Cts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArrivalTime", wireType)
			}
			m.ArrivalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArrivalTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: chunkList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: chunkList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chunks = append(m.Chunks, &Chunk{})
			if err := m.Chunks[len(m.Chunks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkContainer == nil {
				m.ChunkContainer = &ChunkContainer{}
			}
			if err := m.ChunkContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceNode == nil {
				m.SourceNode = &Node{}
			}
			if err := m.SourceNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlaylistMetaEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: playlistMetaEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: playlistMetaEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryMaxBitRate", wireType)
			}
			m.EntryMaxBitRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryMaxBitRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryAvgBitRate", wireType)
			}
			m.EntryAvgBitRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryAvgBitRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryMaxCounter", wireType)
			}
			m.EntryMaxCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryMaxCounter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryMinDuration", wireType)
			}
			m.EntryMinDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryMinDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryMaxDuration", wireType)
			}
			m.EntryMaxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryMaxDuration |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoreRPC
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EventId = append(m.EventId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoreRPC
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCoreRPC
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCoreRPC
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EventId = append(m.EventId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SharedKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoRegister", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoRegister = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamerId", wireType)
			}
			m.StreamerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamerId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNewStreamer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNewStreamer = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastEventId", wireType)
			}
			m.LastEventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastEventId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreamerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateEventRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateEventRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateEventRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaylistRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PlaylistRequest == nil {
				m.PlaylistRequest = &PlaylistRequest{}
			}
			if err := m.PlaylistRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			m.EventId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateTimeUTS", wireType)
			}
			m.GenerateTimeUTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenerateTimeUTS |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Zeromessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: zeromessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: zeromessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkMetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChunkMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChunkMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkContainer == nil {
				m.ChunkContainer = &ChunkContainer{}
			}
			if err := m.ChunkContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chunk == nil {
				m.Chunk = &Chunk{}
			}
			if err := m.Chunk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerMetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerMetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerMetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkContainer == nil {
				m.ChunkContainer = &ChunkContainer{}
			}
			if err := m.ChunkContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerStat == nil {
				m.ContainerStat = &ContainerStat{}
			}
			if err := m.ContainerStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChunkContainer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChunkContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChunkContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreamerId", wireType)
			}
			m.StreamerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreamerId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sts", wireType)
			}
			m.Sts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streamid", wireType)
			}
			m.Streamid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Streamid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Streamid", wireType)
			}
			m.Streamid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Streamid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (StreamType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamsEnum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamsEnum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamsEnum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Map == nil {
				m.Map = make(map[string]*StreamDescriptor)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoreRPC
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCoreRPC
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthCoreRPC
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthCoreRPC
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &StreamDescriptor{}
				if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Map[mapkey] = mapvalue
			} else {
				var mapvalue *StreamDescriptor
				m.Map[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevalidatePeriod", wireType)
			}
			m.RevalidatePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevalidatePeriod |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateTimeUTS", wireType)
			}
			m.GenerateTimeUTS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GenerateTimeUTS |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codecs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codecs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bitrate", wireType)
			}
			m.Bitrate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bitrate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fps", wireType)
			}
			m.Fps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fps |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyframe", wireType)
			}
			m.Keyframe = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Keyframe |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainLastChunk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainLastChunk = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCts", wireType)
			}
			m.MaxCts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCounter", wireType)
			}
			m.MaxCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCounter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MediaInfo == nil {
				m.MediaInfo = &MediaInfo{}
			}
			if err := m.MediaInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamerStsRoute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamerStsRoute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamerStsRoute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChunkContainer == nil {
				m.ChunkContainer = &ChunkContainer{}
			}
			if err := m.ChunkContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerStat == nil {
				m.ContainerStat = &ContainerStat{}
			}
			if err := m.ContainerStat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceNode == nil {
				m.SourceNode = &Node{}
			}
			if err := m.SourceNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamerStsRoutes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamerStsRoutes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamerStsRoutes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCoreRPC
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &StreamerStsRoute{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: heartbeatState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: heartbeatState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= (HeartbeatStateMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			m.Payload = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Payload |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCoreRPC(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCoreRPC
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCoreRPC(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCoreRPC
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCoreRPC
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCoreRPC
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCoreRPC
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCoreRPC(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCoreRPC = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCoreRPC   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("CoreRPC.proto", fileDescriptorCoreRPC) }

var fileDescriptorCoreRPC = []byte{
	// 1646 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x58, 0x4f, 0x73, 0x1b, 0x45,
	0x16, 0x4f, 0x4b, 0x96, 0x22, 0x3d, 0xfd, 0xef, 0x6c, 0x5c, 0x2a, 0xad, 0xcb, 0x71, 0x4d, 0x65,
	0x37, 0xda, 0x6c, 0xd5, 0xc4, 0xab, 0x78, 0x77, 0x21, 0x01, 0x0a, 0x59, 0x31, 0x2e, 0x17, 0xb1,
	0x09, 0x2d, 0x85, 0xe2, 0x04, 0xd5, 0x96, 0xda, 0xf2, 0x54, 0xa4, 0x19, 0xd1, 0xd3, 0x52, 0xac,
	0x70, 0xe3, 0xca, 0x35, 0x07, 0x0a, 0x3e, 0x00, 0xdc, 0x38, 0xf1, 0x0d, 0x38, 0x70, 0xe4, 0x98,
	0x03, 0x07, 0x2a, 0x9c, 0xb8, 0xf3, 0x01, 0xa8, 0xee, 0xe9, 0x99, 0xe9, 0x19, 0x19, 0x62, 0x8a,
	0x0a, 0xb7, 0x7e, 0xbf, 0xfe, 0xf5, 0xeb, 0x7e, 0xaf, 0xdf, 0x9f, 0x9e, 0x81, 0x4a, 0xcf, 0xe3,
	0x8c, 0x3c, 0xe8, 0xd9, 0x33, 0xee, 0x09, 0xcf, 0xea, 0xc0, 0xda, 0x91, 0x37, 0x62, 0x18, 0xc3,
	0x9a, 0x4b, 0xa7, 0xac, 0x89, 0xb6, 0x50, 0xbb, 0x48, 0xd4, 0x18, 0xaf, 0x43, 0x9e, 0xb3, 0xb1,
	0xe3, 0xb9, 0xcd, 0x8c, 0x42, 0xb5, 0x64, 0xdd, 0x80, 0x82, 0x5c, 0x73, 0xdf, 0xf1, 0x05, 0xfe,
	0x3b, 0xe4, 0x5c, 0x6f, 0xc4, 0xfc, 0x26, 0xda, 0xca, 0xb6, 0x4b, 0x9d, 0x9c, 0x2d, 0x67, 0x48,
	0x80, 0x59, 0x77, 0xa1, 0x38, 0x70, 0xa6, 0x8c, 0x50, 0x77, 0xcc, 0x70, 0x13, 0x2e, 0xbf, 0xc5,
	0xbd, 0xe9, 0xc3, 0x41, 0x5f, 0x6d, 0x92, 0x23, 0xa1, 0x88, 0xff, 0x06, 0xb9, 0x81, 0x27, 0xf1,
	0x8c, 0xc2, 0x03, 0xc1, 0x7a, 0x1f, 0xca, 0x9c, 0x7d, 0x34, 0x67, 0xbe, 0xd8, 0x73, 0x05, 0x5f,
	0xe2, 0xb6, 0xa1, 0x4c, 0x69, 0x28, 0x75, 0xc0, 0x8e, 0x10, 0x62, 0xec, 0xb4, 0x09, 0xd0, 0x17,
	0x9c, 0xd1, 0x29, 0xe3, 0x07, 0x23, 0xa5, 0x34, 0x4b, 0x0c, 0xc4, 0xfa, 0x02, 0xc1, 0xd5, 0xde,
	0xe9, 0xdc, 0x7d, 0xd4, 0xf3, 0x5c, 0x41, 0x1d, 0x97, 0x71, 0x12, 0x6c, 0xf4, 0x07, 0xf6, 0xf8,
	0x3f, 0x54, 0x87, 0x09, 0x15, 0x6a, 0x9f, 0x52, 0xa7, 0x66, 0xa7, 0x34, 0xa7, 0x68, 0xf8, 0x1a,
	0xe4, 0x8e, 0x94, 0xc3, 0xb2, 0x8a, 0x5f, 0xb4, 0x43, 0x57, 0x92, 0x00, 0xb7, 0x7e, 0x41, 0x50,
	0x9b, 0x4d, 0xe8, 0x72, 0x22, 0x31, 0x7d, 0xae, 0x57, 0xa1, 0x4e, 0x0c, 0x5f, 0x48, 0xba, 0x76,
	0x78, 0xc5, 0x36, 0x9d, 0x44, 0x56, 0x68, 0xf8, 0xdf, 0xd0, 0xe0, 0x6c, 0x41, 0x27, 0xce, 0x88,
	0x0a, 0xf6, 0xe1, 0x8c, 0x71, 0xc7, 0x1b, 0x69, 0x47, 0xd7, 0xe3, 0x89, 0x07, 0x0a, 0xc7, 0x6d,
	0xa8, 0xed, 0x33, 0x97, 0x71, 0x2a, 0x98, 0x34, 0x55, 0xde, 0x49, 0x56, 0xb9, 0x2f, 0x0d, 0x4b,
	0xe6, 0x2e, 0xa3, 0xdc, 0x71, 0xc7, 0x81, 0x63, 0x9d, 0x51, 0x73, 0x4d, 0x29, 0x4d, 0xc3, 0xf8,
	0x1f, 0x00, 0xbe, 0x37, 0xe7, 0x43, 0x26, 0xcd, 0x6b, 0xe6, 0x94, 0xd5, 0x3a, 0x4c, 0x8c, 0x09,
	0xeb, 0x19, 0x82, 0x42, 0x68, 0x36, 0xde, 0x81, 0xca, 0x03, 0x3d, 0x56, 0x96, 0x68, 0x63, 0xab,
	0xf6, 0xcc, 0x44, 0x49, 0x92, 0xf4, 0xb2, 0x4c, 0x6d, 0xc2, 0xe5, 0xbd, 0x05, 0x73, 0xc5, 0x41,
	0x60, 0x62, 0x96, 0x84, 0xe2, 0x45, 0x4d, 0xdb, 0x87, 0x4a, 0xe2, 0xdc, 0xf8, 0x7f, 0x50, 0x0b,
	0x4f, 0xde, 0x17, 0xbe, 0x71, 0x9b, 0xe5, 0xc8, 0xc0, 0xbe, 0xf0, 0x49, 0x9a, 0x64, 0xfd, 0x80,
	0xa0, 0x64, 0x10, 0x64, 0x82, 0xf6, 0x85, 0x1f, 0x67, 0x94, 0x96, 0xf0, 0x75, 0x28, 0xaa, 0x28,
	0x54, 0x9a, 0x33, 0x4a, 0x73, 0xde, 0x56, 0x71, 0x48, 0xe2, 0x09, 0xfc, 0x1a, 0xc0, 0x94, 0x09,
	0xba, 0xe7, 0x0a, 0x47, 0x85, 0xa3, 0xa4, 0x6d, 0x98, 0x07, 0xb0, 0x0f, 0xa3, 0xe9, 0xc0, 0xdf,
	0x06, 0xbf, 0xf5, 0x2e, 0xd4, 0x52, 0xd3, 0xb8, 0x0e, 0xd9, 0x47, 0x6c, 0xa9, 0xcf, 0x22, 0x87,
	0xb8, 0x0d, 0xb9, 0x05, 0x9d, 0xcc, 0x99, 0x4e, 0x0e, 0x1c, 0x69, 0xd7, 0x4b, 0xf9, 0x92, 0x04,
	0x84, 0x3b, 0x99, 0x57, 0x90, 0xf5, 0x25, 0x82, 0x9c, 0x3a, 0xa5, 0x74, 0x79, 0xcf, 0x9b, 0xbb,
	0x82, 0xf1, 0xb0, 0x56, 0x68, 0x11, 0xb7, 0xa0, 0x70, 0x6f, 0xce, 0xa9, 0x08, 0xab, 0x52, 0x8e,
	0x44, 0xb2, 0xdc, 0x7f, 0x28, 0x82, 0xc4, 0xca, 0x11, 0x39, 0xc4, 0x5b, 0x50, 0xea, 0x72, 0xee,
	0x2c, 0xe8, 0x44, 0x5e, 0xa6, 0xba, 0xa1, 0x2c, 0x31, 0x21, 0xbc, 0xa1, 0x5d, 0xd5, 0x77, 0x9e,
	0xb0, 0x66, 0x5e, 0xad, 0x8c, 0x01, 0xe9, 0xe0, 0x03, 0xff, 0x3e, 0xf5, 0x45, 0xf3, 0xf2, 0x16,
	0x6a, 0x17, 0x88, 0x96, 0xac, 0x4f, 0x11, 0x14, 0x87, 0x91, 0x23, 0x37, 0x21, 0xaf, 0x96, 0x84,
	0x45, 0x30, 0xf4, 0xb5, 0x46, 0x65, 0xad, 0xe8, 0x5d, 0xac, 0x56, 0x24, 0x65, 0x19, 0x5f, 0xfd,
	0x38, 0xbe, 0xb2, 0x89, 0xf8, 0x8a, 0x27, 0xac, 0x9f, 0x11, 0x34, 0x56, 0x1c, 0x2b, 0x03, 0x5c,
	0x0d, 0x0e, 0xe9, 0xd9, 0xae, 0x23, 0x08, 0x15, 0x4c, 0xfb, 0x32, 0x0d, 0x47, 0xcc, 0xee, 0x62,
	0x1c, 0x32, 0x33, 0x06, 0x33, 0x86, 0x4d, 0x9d, 0xe1, 0xfd, 0x64, 0x93, 0x3a, 0xc3, 0x7b, 0xba,
	0x09, 0xf5, 0x00, 0x72, 0xdc, 0xe8, 0xbe, 0x82, 0x02, 0xb1, 0x82, 0xc7, 0x5c, 0x7a, 0x16, 0x71,
	0x73, 0x26, 0x37, 0xc6, 0xad, 0x36, 0x94, 0x55, 0xf6, 0x85, 0x95, 0xd1, 0x48, 0x4e, 0xe9, 0xfc,
	0x38, 0x39, 0xad, 0xc7, 0x50, 0x0b, 0x6b, 0x7e, 0x48, 0xb6, 0xa0, 0x1c, 0x42, 0x47, 0x71, 0xb3,
	0x4b, 0x60, 0x32, 0x20, 0xfa, 0xa7, 0x94, 0xb3, 0xd1, 0xdb, 0x6c, 0xa9, 0xfb, 0x5e, 0x0c, 0x48,
	0x0d, 0xdd, 0xb9, 0xf0, 0x08, 0x1b, 0x3b, 0x7e, 0x68, 0x7d, 0x81, 0x24, 0x30, 0xeb, 0x73, 0x14,
	0x6f, 0x73, 0xe0, 0x9e, 0x78, 0xa9, 0x7e, 0x84, 0xd2, 0xfd, 0x08, 0x5f, 0x87, 0xca, 0x81, 0x7f,
	0xc4, 0x1e, 0x87, 0x90, 0xda, 0xb6, 0x40, 0x92, 0xa0, 0x8c, 0x65, 0x19, 0x7b, 0xa1, 0xb5, 0x41,
	0xb1, 0x32, 0xa1, 0x15, 0xf3, 0xd6, 0x56, 0xcd, 0xb3, 0x9e, 0x22, 0xc0, 0x3d, 0xce, 0xa8, 0x60,
	0x09, 0x37, 0xde, 0x89, 0x2b, 0x92, 0x86, 0x74, 0xfb, 0xab, 0xdb, 0xa9, 0x5e, 0x44, 0xd2, 0x44,
	0xf3, 0x0a, 0x32, 0xc9, 0xfa, 0x78, 0xe1, 0x1a, 0x6b, 0x55, 0xa0, 0xf4, 0x84, 0x71, 0x6f, 0xca,
	0x7c, 0x9f, 0x8e, 0x99, 0x75, 0x02, 0x15, 0x95, 0x0a, 0x32, 0x9a, 0xef, 0x51, 0x41, 0xcf, 0x69,
	0xb7, 0xe8, 0x62, 0xed, 0x76, 0x03, 0x72, 0x8a, 0xa1, 0x53, 0x2e, 0x4c, 0xcd, 0x00, 0xb4, 0x3e,
	0x41, 0xd0, 0x88, 0xb8, 0x7f, 0x7e, 0xb3, 0x1d, 0xa8, 0x0c, 0x43, 0xa1, 0x2f, 0xa8, 0xd0, 0x9b,
	0x56, 0xed, 0x9e, 0x89, 0x92, 0x24, 0xc9, 0xfa, 0x20, 0x5d, 0x1e, 0x5e, 0x18, 0x30, 0x75, 0xc8,
	0xfa, 0xc2, 0xd7, 0x49, 0x2a, 0x87, 0xb2, 0x2c, 0xfa, 0xc9, 0x3e, 0x1c, 0xc9, 0xd6, 0x10, 0xea,
	0xc1, 0xda, 0x7b, 0xcc, 0x1f, 0x72, 0x67, 0x26, 0x3c, 0x9e, 0xe0, 0xa3, 0x24, 0x1f, 0x5f, 0x83,
	0xb5, 0xc1, 0x72, 0x16, 0xd4, 0x80, 0x6a, 0xa7, 0x64, 0x07, 0x8b, 0x25, 0x44, 0xd4, 0x84, 0x7c,
	0x2b, 0xaa, 0xf8, 0xca, 0x06, 0x6f, 0x45, 0x15, 0x57, 0xcf, 0x10, 0x94, 0x02, 0xa2, 0xbf, 0xe7,
	0xce, 0xa7, 0xf8, 0x06, 0x64, 0x0f, 0xe9, 0x4c, 0x17, 0xc4, 0xab, 0xb6, 0x31, 0x65, 0x1f, 0xd2,
	0x59, 0x50, 0xfa, 0x25, 0xe3, 0x25, 0x35, 0xed, 0xd6, 0x01, 0x14, 0xc2, 0x7d, 0xcc, 0xbe, 0x54,
	0x0c, 0xfa, 0xd2, 0x8d, 0x64, 0x5f, 0x6a, 0xd8, 0x69, 0x07, 0x99, 0x6d, 0xe9, 0x6b, 0x04, 0xc5,
	0x43, 0x36, 0x72, 0xa8, 0x4a, 0xe6, 0x75, 0xc8, 0x0f, 0xbd, 0x11, 0x1b, 0xfa, 0x5a, 0x9f, 0x96,
	0xe4, 0x9d, 0x71, 0xe6, 0x7b, 0x93, 0xb9, 0x88, 0x1f, 0xcc, 0x06, 0x22, 0xb3, 0xe4, 0xd8, 0x11,
	0xf2, 0x88, 0xea, 0xc8, 0x15, 0x12, 0x8a, 0xf2, 0x78, 0x27, 0x33, 0x5f, 0x5d, 0x5b, 0x85, 0xc8,
	0xa1, 0xbc, 0x9d, 0x47, 0x6c, 0x79, 0xc2, 0xa9, 0xee, 0x59, 0x15, 0x12, 0xc9, 0xea, 0xee, 0x29,
	0x57, 0xad, 0xaa, 0x48, 0xe4, 0x50, 0x22, 0x23, 0xca, 0x55, 0x87, 0x2a, 0x12, 0x39, 0xb4, 0xbe,
	0x41, 0xf2, 0x99, 0x6f, 0xc4, 0x98, 0x2c, 0xb1, 0x1a, 0x90, 0x05, 0x23, 0xc8, 0x08, 0xa4, 0xaa,
	0xcc, 0x0a, 0x2e, 0x2d, 0x9c, 0xd2, 0xb3, 0x5e, 0x14, 0x60, 0x5a, 0x92, 0x16, 0x4e, 0xd3, 0x75,
	0xdf, 0x40, 0xe4, 0xba, 0x09, 0x73, 0xc7, 0xe2, 0x54, 0x47, 0xa0, 0x96, 0xe4, 0xa3, 0x3a, 0x72,
	0x9f, 0x7e, 0x24, 0x81, 0x1d, 0x21, 0x24, 0x9e, 0xb4, 0xbe, 0x42, 0x61, 0xa8, 0xca, 0x63, 0xfb,
	0xc4, 0x9b, 0x0b, 0xf6, 0x17, 0x67, 0x63, 0xea, 0x4d, 0x97, 0xfd, 0xad, 0x37, 0xdd, 0x1b, 0xd0,
	0x48, 0x9f, 0xd4, 0xc7, 0xff, 0x82, 0x7c, 0x30, 0xd2, 0x71, 0x1f, 0xc6, 0x55, 0xcc, 0x21, 0x9a,
	0x60, 0x9d, 0x41, 0xf5, 0x94, 0x51, 0x2e, 0x8e, 0x19, 0x15, 0x72, 0x5f, 0x86, 0x6d, 0xc8, 0x1f,
	0x32, 0x71, 0xea, 0x05, 0x09, 0x59, 0xed, 0xac, 0xdb, 0x49, 0x82, 0x3d, 0x55, 0xb3, 0x44, 0xb3,
	0x64, 0x40, 0xcd, 0xe8, 0x72, 0xe2, 0xd1, 0xa8, 0xec, 0x6a, 0xd1, 0xda, 0x80, 0x7c, 0xc0, 0xc5,
	0x05, 0x58, 0x9b, 0x39, 0xee, 0xb8, 0x7e, 0x49, 0x8d, 0x3c, 0x77, 0x5c, 0x47, 0x37, 0xbb, 0x61,
	0x71, 0x51, 0xb9, 0x5c, 0x97, 0x0d, 0x6d, 0xe4, 0x78, 0xef, 0x39, 0x23, 0xe6, 0x0d, 0xfa, 0xf5,
	0x4b, 0x11, 0xf2, 0x8e, 0x3b, 0x59, 0x76, 0xbb, 0xbd, 0x3a, 0xc2, 0x35, 0x28, 0xa9, 0x69, 0x89,
	0x0c, 0xfa, 0xf5, 0x4c, 0xe7, 0x63, 0xa8, 0xf6, 0x85, 0xc7, 0xe9, 0x98, 0xf5, 0x19, 0x5f, 0x38,
	0x43, 0x86, 0x6f, 0x43, 0x2d, 0xe8, 0x2a, 0xb1, 0xfb, 0xb1, 0xbd, 0x52, 0x59, 0x5b, 0x65, 0xdb,
	0xa8, 0xf2, 0x78, 0x07, 0xca, 0xfb, 0x4c, 0xc4, 0x2b, 0xd6, 0xed, 0x73, 0xbf, 0xca, 0x5a, 0x60,
	0x47, 0x6f, 0xad, 0x6d, 0xd4, 0x79, 0x9a, 0x81, 0x86, 0x54, 0xb8, 0x3f, 0xf1, 0x8e, 0xe9, 0x24,
	0x3c, 0xc0, 0x7f, 0xe0, 0xca, 0x3e, 0x13, 0xba, 0xcc, 0x74, 0x17, 0xd4, 0x99, 0xd0, 0xe3, 0x09,
	0xc3, 0x89, 0x0d, 0x5b, 0x65, 0xb3, 0x0e, 0xe1, 0xff, 0x02, 0xde, 0x67, 0x22, 0xdd, 0xcd, 0x2a,
	0xb6, 0xd9, 0x18, 0x5b, 0x2b, 0xfd, 0x0f, 0x77, 0x64, 0x0d, 0x12, 0x89, 0x06, 0x5f, 0xb7, 0x53,
	0x2f, 0x8d, 0x56, 0xc5, 0x4e, 0x10, 0xb6, 0xa1, 0x64, 0x34, 0x5d, 0x7c, 0xc5, 0x5e, 0x6d, 0xc1,
	0x29, 0xdf, 0xdc, 0x52, 0xbb, 0x24, 0x7a, 0x74, 0xf2, 0x53, 0xaf, 0x95, 0x3c, 0x68, 0xe7, 0x5b,
	0x04, 0x57, 0x82, 0x3d, 0x55, 0x84, 0xf1, 0xd0, 0x31, 0x77, 0x94, 0x63, 0x14, 0xb6, 0xbb, 0x8c,
	0x7d, 0x9d, 0xce, 0x9e, 0x16, 0xb6, 0x57, 0xe3, 0xf9, 0x75, 0x58, 0x8f, 0xd7, 0x9a, 0x5f, 0x96,
	0xe9, 0xb3, 0x9c, 0xb3, 0x78, 0x1b, 0xe1, 0x0e, 0x54, 0xc3, 0x47, 0x91, 0x56, 0x78, 0x0e, 0x2f,
	0x69, 0x77, 0x67, 0x00, 0x1b, 0xa6, 0x15, 0xdd, 0xd1, 0x82, 0x71, 0xe1, 0xf8, 0x51, 0xa0, 0xed,
	0x40, 0x35, 0xc2, 0x82, 0xfa, 0xf0, 0x42, 0x9d, 0x6d, 0xd4, 0xb9, 0x0b, 0x8d, 0x01, 0xa7, 0xae,
	0x2f, 0x6b, 0x75, 0xe4, 0x99, 0x7f, 0x42, 0xfe, 0xc8, 0x13, 0xce, 0xc9, 0x12, 0x57, 0xed, 0xc4,
	0x6b, 0x23, 0x75, 0xa4, 0x39, 0x54, 0xa5, 0x9b, 0xb8, 0x17, 0x05, 0xdb, 0x2d, 0x28, 0x87, 0x86,
	0x3d, 0xf4, 0x19, 0x7f, 0xf1, 0xfd, 0x77, 0xa0, 0x11, 0x2e, 0xf8, 0xfd, 0x04, 0x89, 0x7f, 0x07,
	0x74, 0xde, 0x84, 0x62, 0x54, 0x00, 0xf0, 0x6d, 0xd9, 0x5d, 0xa9, 0x60, 0x81, 0x56, 0x5c, 0x4b,
	0xd5, 0x86, 0x56, 0x1a, 0x68, 0xa3, 0x6d, 0xb4, 0x5b, 0xff, 0xee, 0xf9, 0x26, 0xfa, 0xfe, 0xf9,
	0x26, 0xfa, 0xf1, 0xf9, 0x26, 0xfa, 0xec, 0xa7, 0xcd, 0x4b, 0xc7, 0x79, 0xf5, 0xd3, 0xe7, 0xf6,
	0xaf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x12, 0xee, 0xd9, 0xf7, 0x05, 0x12, 0x00, 0x00,
}
